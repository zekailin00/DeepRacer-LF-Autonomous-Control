// src/Joystick.lf
target CCpp {
    cmake-include: "include/composition.cmake",
    coordination: decentralized
};

preamble {=
    #include "joy-ctrl.h"

    #include <iostream>
    #include <fstream>
    #include <vector>
    #include <string>

    template<typename POD>
    std::ostream& serialize(std::ostream& os, std::vector<POD> const& v)
    {
        // this only works on built in data types (PODs)
        static_assert(std::is_trivial<POD>::value && std::is_standard_layout<POD>::value,
            "Can only serialize POD types with this function");

        auto size = v.size();
        os.write(reinterpret_cast<char const*>(&size), sizeof(size));
        os.write(reinterpret_cast<char const*>(v.data()), v.size() * sizeof(POD));
        return os;
    }

    template<typename POD>
    std::istream& deserialize(std::istream& is, std::vector<POD>& v)
    {
        static_assert(std::is_trivial<POD>::value && std::is_standard_layout<POD>::value,
            "Can only deserialize POD types with this function");

        decltype(v.size()) size;
        is.read(reinterpret_cast<char*>(&size), sizeof(size));
        v.resize(size);
        is.read(reinterpret_cast<char*>(v.data()), v.size() * sizeof(POD));
        return is;
    }

    std::vector<float> throttle_list;
    std::vector<float> angle_list;
    std::vector<float> time_list;

    void serialize_vector(std::vector<float> &vector, std::string filename) {
        std::fstream output_fstream;

        output_fstream.open(filename, std::ios_base::out);
        if(!output_fstream.is_open()) {
            std::cout<<"ERROR: file not open - " << filename << std::endl;
        } else {
            serialize<float>(output_fstream, vector);
            output_fstream.close();
        }
    }

    void deserialize_vector(std::vector<float> &vector, std::string filename) {
        std::fstream input_fstream;

        input_fstream.open(filename, std::ios_base::in);
        if(!input_fstream.is_open()) {
            std::cout<<"ERROR: file not open - " << filename << std::endl;
        } else {
            deserialize<float>(input_fstream, vector);
            input_fstream.close();
        }
    }

    std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg> servoMsg;
=}



reactor Joystick {
    // Instantiate the publisher node as a sate variable
    //state joystick_node : std::shared_ptr<DeepRacerJoyControl>;
    output servo_msg:std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg>;
    output activate_cam: bool;
    timer t(0, 25 ms);

    physical action play_back;
    logical action pop;

    state count_ : size_t;
    state JOYSTICK_DEV : std::string;
    state data : ControllerData;
    state joystick_fd : int;
    state num_of_axis : int;
    state num_of_buttons : int;
    state name_of_joystick : char[80];
    state pause: int;

    state count : int;
    state begin_time: float;

    state record_mode : int;
    state offset: interval_t;
    state press_count: int;
    state playback : bool;

    reaction(startup) {=

        self->JOYSTICK_DEV = "/dev/input/js0";
        self->count_ = 0;
        self->pause = 0;
        self->record_mode = -1;
        self->press_count = 0;
        self->playback = false;
        self->count = 0;

        servoMsg = std::make_shared<deepracer_interfaces_pkg::msg::ServoCtrlMsg>(); 


        std::cout<< "[LF] Open joystick file descriptor;"<<std::endl;

        self->joystick_fd = open(self->JOYSTICK_DEV.c_str(), O_RDONLY | O_NONBLOCK);
        if (self->joystick_fd < 0) 
        {
            lf_print( "[LF] Joystick error: %d", self->joystick_fd); 
            exit(1);
        }

        std::cout<< "[LF] Read joystick meta data."<<std::endl;

        ioctl(self->joystick_fd, JSIOCGAXES, &(self->num_of_axis));
        lf_print("Joystick Number of Axes: %d", self->num_of_axis);

        ioctl(self->joystick_fd, JSIOCGBUTTONS, &(self->num_of_buttons));
        lf_print( "Joystick Number of Buttons: %d", self->num_of_buttons);

        ioctl(self->joystick_fd, JSIOCGNAME(80), self->name_of_joystick); 
        lf_print( "Joystick Connected: %s", self->name_of_joystick);
    
        self->data.joy_button.resize(self->num_of_buttons, 0);
        self->data.joy_axis.resize(self->num_of_axis, 0);

        //std::cout<< "[LF] Finished reactor startup."<<std::endl;
    =}

    reaction(play_back) -> pop {=
        lf_print("Deserializing recorded keys");

        deserialize_vector(throttle_list, "throttle_list.txt");
        deserialize_vector(angle_list, "angle_list.txt");
        deserialize_vector(time_list, "time_list.txt");
        servoMsg = std::make_shared<deepracer_interfaces_pkg::msg::ServoCtrlMsg>(); 

        if (throttle_list.size() != angle_list.size() || throttle_list.size() != time_list.size() || time_list.size() != angle_list.size()) {
                lf_print("ERROR: vector sizes do not match.");
                exit(1);
            }

        lf_print("Begin replay.");
        float begin_time = lf_time_physical_elapsed();
        int count = 0;
        while(count < throttle_list.size()) {
            float elapse = lf_time_physical_elapsed() - begin_time;
            if (elapse > time_list[count]) { 
                servoMsg->angle = angle_list[count];
                servoMsg->throttle = throttle_list[count]; 
                lf_print("playback: angle: %f, throttle: %f at %f", servoMsg->angle, servoMsg->throttle, elapse);
                count++;
                lf_schedule(pop, 0);
            }
        }
        //self->playback = false;
    =}

    reaction(pop) -> servo_msg, pop {=
        if(self->count < throttle_list.size()) {
            float elapse = lf_time_physical_elapsed() - self->begin_time;
            if (elapse > time_list[self->count]) { 
                servoMsg->angle = angle_list[self->count];
                servoMsg->throttle = throttle_list[self->count]; 
                lf_print("playback: angle: %f, throttle: %f at %f", servoMsg->angle, servoMsg->throttle, elapse);
                lf_print("count: %d", self->count);
                lf_print("vector size: %d", throttle_list.size());
                lf_set(servo_msg, servoMsg);
                self->count++;
            }
            lf_print("poping message");
            lf_print("poping message");
            lf_schedule(pop, 0);
        }
    =} 

    reaction(t) -> servo_msg, activate_cam, pop {=
        self->count_++;
        js_event js, prev_js;
        int retval;
        bool emptyQueue = false;
        //lf_print( "Enter while(read)...");
        int while_count = 0; 
        while (retval = read (self->joystick_fd, &js, sizeof(js_event)) > 0) {
            prev_js = js;
            while_count++;

            switch (prev_js.type & ~JS_EVENT_INIT)
                {
                case JS_EVENT_AXIS:
                    if(!((int)prev_js.number>=self->data.joy_axis.size()))
                    self->data.joy_axis[(int)prev_js.number]= prev_js.value;
                    break;
                case JS_EVENT_BUTTON:
                    if(!((int)prev_js.number>=self->data.joy_button.size()))
                    self->data.joy_button[(int)prev_js.number]= prev_js.value;
                    break;
            }
        }

        //lf_print( "Exit while(read) - Return value of read is: %d", retval);
        //lf_print( "Exit while(read) - while count: %d", while_count);

        std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg> servoMsg = std::make_shared<deepracer_interfaces_pkg::msg::ServoCtrlMsg>();  
        servoMsg->angle = -(static_cast<float>(self->data.joy_axis[0])/INT16_MAX);
        servoMsg->throttle = -(static_cast<float>(self->data.joy_axis[1])/INT16_MAX); 
        auto physical_time = get_elapsed_physical_time();
        //lf_print( "physical time: %lld", physical_time);
        //lf_print( "Send message at step %d: angle %f, throttle %f", self->count_, servoMsg->angle, servoMsg->throttle);

        if (!self->playback) {
            lf_print("angle: %f, throttle: %f", servoMsg->angle, servoMsg->throttle);
            lf_set(servo_msg, servoMsg);
        }


        if (self->pause != 0) self->pause--;

        if (self->data.joy_button[2] > 0 && self->pause == 0) {
            lf_set(activate_cam, true);
            lf_print("Activate Camera");
            self->pause = 10;
        } else if (self->data.joy_button[1] > 0 && self->pause == 0) {
            lf_set(activate_cam, false);
            lf_print("Stop Camera");
            self->pause = 10;
        }
        else if(self->press_count >= 2){
            lf_print("file save");
            serialize_vector(throttle_list, "throttle_list.txt");
            serialize_vector(angle_list, "angle_list.txt");
            serialize_vector(time_list, "time_list.txt");
            self->press_count = 0;
            self->record_mode = self->record_mode*-1;
        } else if (self->data.joy_button[0] > 0 && self->pause == 0) {
            self->record_mode = self->record_mode*-1;
            lf_print("Turned on record mode");
            self->pause = 10;
            self->offset = lf_time_physical_elapsed();
            self->press_count = self->press_count + 1;
        } else if (self->data.joy_button[3] > 0 && self->pause == 0) {
            lf_print("Turned on play back");
            self->pause = 10;
            self->playback = true;
            self->begin_time = lf_time_physical_elapsed();
            lf_schedule(pop, 0);
        }
        if (self->record_mode>0){
            float current_time = lf_time_physical_elapsed()-self->offset;
            angle_list.push_back(servoMsg->angle);
            throttle_list.push_back(servoMsg->throttle);
            time_list.push_back(current_time);
        }
    =}

    reaction(shutdown) {= =}
}