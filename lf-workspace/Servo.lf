// src/Servo.lf
target CCpp {
    cmake-include: "include/composition.cmake",
    coordination: decentralized
};

preamble {=
    #include "rclcpp/rclcpp.hpp"
    #include "servo_pkg/servo_mgr.hpp"
    #include "servo_pkg/led_mgr.hpp"
    #include <rclcpp/strategies/message_pool_memory_strategy.hpp>
    #include "deepracer_interfaces_pkg/msg/servo_ctrl_msg.hpp"
    #include "deepracer_interfaces_pkg/srv/get_calibration_srv.hpp"
    #include "deepracer_interfaces_pkg/srv/set_calibration_srv.hpp"
    #include "deepracer_interfaces_pkg/srv/set_led_ctrl_srv.hpp"
    #include "deepracer_interfaces_pkg/srv/get_led_ctrl_srv.hpp"
    #include "deepracer_interfaces_pkg/srv/servo_gpio_srv.hpp"




    #include <iostream>
    #include <fstream>
    #include <vector>
    #include <string>

    template<typename POD>
    std::ostream& serialize(std::ostream& os, std::vector<POD> const& v)
    {
        // this only works on built in data types (PODs)
        static_assert(std::is_trivial<POD>::value && std::is_standard_layout<POD>::value,
            "Can only serialize POD types with this function");

        auto size = v.size();
        os.write(reinterpret_cast<char const*>(&size), sizeof(size));
        os.write(reinterpret_cast<char const*>(v.data()), v.size() * sizeof(POD));
        return os;
    }

    template<typename POD>
    std::istream& deserialize(std::istream& is, std::vector<POD>& v)
    {
        static_assert(std::is_trivial<POD>::value && std::is_standard_layout<POD>::value,
            "Can only deserialize POD types with this function");

        decltype(v.size()) size;
        is.read(reinterpret_cast<char*>(&size), sizeof(size));
        v.resize(size);
        is.read(reinterpret_cast<char*>(v.data()), v.size() * sizeof(POD));
        return is;
    }

    std::vector<float> throttle_list;
    std::vector<float> angle_list;
    std::vector<float> time_list;

    void serialize_vector(std::vector<float> &vector, std::string filename) {
        std::fstream output_fstream;

        output_fstream.open(filename, std::ios_base::out);
        if(!output_fstream.is_open()) {
            std::cout<<"ERROR: file not open - " << filename << std::endl;
        } else {
            serialize<float>(output_fstream, vector);
            output_fstream.close();
        }
    }

    void deserialize_vector(std::vector<float> &vector, std::string filename) {
        std::fstream input_fstream;

        input_fstream.open(filename, std::ios_base::in);
        if(!input_fstream.is_open()) {
            std::cout<<"ERROR: file not open - " << filename << std::endl;
        } else {
            deserialize<float>(input_fstream, vector);
            input_fstream.close();
        }
    }
=}

reactor Servo {
    // Instantiate the subscriber node as a sate variable
    state node : std::shared_ptr<rclcpp::Node>;
    state pServoMgr : std::shared_ptr<PWM::ServoMgr>;
    state pLedMgr : std::shared_ptr<PWM::LedMgr>;

    input servo_msg : std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg>;
    input raw_pwm : std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg>;
    input playback : bool;

    reaction(startup) {=
        rclcpp::init(0, NULL);
        self->node = rclcpp::Node::make_shared("servo_node");
        self->pServoMgr = std::make_unique<PWM::ServoMgr>(self->node->get_logger());
        self->pLedMgr = std::make_unique<PWM::LedMgr>(self->node->get_logger());

        lf_print("[LF Servo Reactor] Initialized");
    =}

    reaction(playback) {=
        throttle_list = {};
        angle_list = {};
        time_list = {};

        deserialize_vector(throttle_list, "throttle_list.txt");
        deserialize_vector(angle_list, "angle_list.txt");
        deserialize_vector(time_list, "time_list.txt");
        std::shared_ptr<deepracer_interfaces_pkg::msg::ServoCtrlMsg> servoMsg = std::make_shared<deepracer_interfaces_pkg::msg::ServoCtrlMsg>(); 

        if (throttle_list.size() != angle_list.size() || throttle_list.size() != time_list.size() || time_list.size() != angle_list.size()) {
                lf_print("ERROR: vector sizes do not match.");
                exit(1);
            }

        lf_print("Begin replay.");
        float begin_time = lf_time_physical_elapsed();
        int count = 0;
        while(count < throttle_list.size()) {
            float elapse = lf_time_physical_elapsed() - begin_time;
            if (elapse > time_list[count]) { 
                servoMsg->angle = angle_list[count];
                servoMsg->throttle = throttle_list[count]; 
                lf_print("playback: angle: %f, throttle: %f at %f", servoMsg->angle, servoMsg->throttle, elapse);
                count++;
                self->pServoMgr->servoSubscriber(servoMsg);
            }
        }
    =}


    reaction(servo_msg) {=
        //lf_print("[LF::Servo::servo_msg] Angle: %f, Throttle %f", servo_msg->value->angle, servo_msg->value->throttle);
        self->pServoMgr->servoSubscriber(servo_msg->value);
    =}

    reaction(raw_pwm) {=
       // lf_print("[LF::Servo::raw_pwm] Angle: %f, Throttle %f", raw_pwm->value->angle, raw_pwm->value->throttle);
        self->pServoMgr->rawPWMSubscriber(raw_pwm->value);
    =}

    reaction(shutdown) {=
        rclcpp::shutdown();
    =}
}